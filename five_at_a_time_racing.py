# -*- coding: utf-8 -*-
"""five_at_a_time_racing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ky6zzA7NlowFVhAERSdy6ZTJYZAmnEi_
"""

### This program simulates races between n runners and determines the fastest
### 3 without use of a timer.
### Runners can only race in groups of 5 and the fastests of each groups are raced
### until one fastest is determined.
### The fastest and 2nd fastest of the runner-ups are 2nd and 3rd fastest overall.

import numpy as np

### This is a global string variable that stores data to be printed after the
### program has run.
print_str = ""

### This is a global int variable used to keep track of the number of racers.
### Increases in increments of 1 every time the lets_race function is called.
num_of_races = 0

### This is a global int used to count the number of times a fastest runner
### has been announced. (It should only happen once per iteration)
winner_announcement = 0



### Begins the initial races for all runners.
### If there are more than 5, it calls on the find_top_three function to search
### through each sublist for the runners with the highest performance values.
### If there are five or fewer runners, it races them and returns the top 3.
def initiate_races(runners):
  if len(runners) > 5:
    racing_groups = making_groups(runners)
    build_print_str(("\033[4m" + "Intitial Groups:" + "\033[0m"))
    create_grid(racing_groups)
    for group in racing_groups:
      lets_race(group)
    build_print_str(("\n" + "\033[4m" + "Result of All Groups' Races:" + "\033[0m"))
    create_grid(racing_groups)
    return find_top_three(racing_groups)
  else:
    lets_race(runners)
    create_grid(runners)
    final_three = []
    for runner in runners:
      if len(final_three) < 3:
        final_three.append(runner)
      else:
        break
    return final_three

### Returns a list with the top 3 runners within a list of sublists.
### Recursively checks the sublists with the fastest runners and eliminates
### sublists that do not qualify.
def find_top_three(runners):
  global winner_announcement

  build_print_str(("\n\033[4m" + "Adjusted Groups:" + "\033[0m"))
  racing_groups = making_groups(runners)

  if len(runners) > 5:
    create_grid(racing_groups)
    for group in racing_groups:
      lets_race(group)
    create_grid(racing_groups)
    runners = find_top_three(racing_groups)
  else:
    create_grid(racing_groups)
    lets_race(runners)
    racing_groups = making_groups(runners)
    create_grid(racing_groups)

  if winner_announcement <1:
    build_print_str(("\n\033[1m" + "The fastest runner is decided!" + "\033[0m"))
    build_print_str(("\033[1m" + "It's Runner " + str(get_runner_number(runners)) + "!" + "\033[0m"))
    build_print_str(("\033[1m" + "Time to find second and third place!" + "\033[0m\n"))
    winner_announcement += 1

  build_print_str(("\n\033[4m" + "Moving back to the previous group:" + "\033[0m"))
  create_grid(runners)

  # If runners is a list that doesn't not contain tuples two layers in, a
  # potential shortcut is possible in order to avoid finding multiple levels
  # of runner-ups.
  if isinstance(runners[0], tuple) or isinstance(runners[0][0], tuple):
    # A list of lists of tuples has runner-ups in the first list's second and third
    # index, the second list's first and second index, and the third list's first index
    if isinstance(runners[0][0], tuple):
      build_print_str(("\n\033[4m" + "Runner-ups:" + "\033[0m"))
      runner_ups = get_runnerups(runners)
      ru_groups = making_groups(runner_ups)
      create_grid(ru_groups)
      lets_race(runner_ups)
      ru_groups = making_groups(runner_ups)
      create_grid(ru_groups)
      first_place = runners[0][0]
      second_place = runner_ups[0]
      third_place = runner_ups[1]
      final_three = [first_place, second_place, third_place]
      build_print_str(("\n\033[1m" + "Second and third place for this group has been found!" + "\033[0m"))
      build_print_str(("\033[1m" + "Second place is Runner " + str(get_runner_number(final_three[1])) + "!" + "\033[0m"))
      build_print_str(("\033[1m" + "Third place is Runner " + str(get_runner_number(final_three[2])) + "!" + "\033[0m\n"))
    else:
      # If runners is already a list of tuples, it's already been completely raced.
      final_three = runners
  else:
    final_three = take_shortcut(runners)
    build_print_str(("\033[1m" + "Second and third place for this group has been found!" + "\033[0m"))
    build_print_str(("\033[1m" + "Second place is Runner " + str(get_runner_number(final_three[1])) + "!" + "\033[0m"))
    build_print_str(("\033[1m" + "Third place is Runner " + str(get_runner_number(final_three[2])) + "!" + "\033[0m\n"))


  return final_three

### Checks if the fastest runner of the 2nd group is faster than the 2 potential
### second place runners of the 1st group by racing them against the 2nd group's
### potential 3rd  place runners and the 3rd group's potential third place runner.
### If any of the 3rd place runners are faster than the 2nd place runners, the
### fastest of the second group is considered second place, and the fastest of
### of the other 5 is considered 3rd.
### Otherwise, all potential second place runners are raced against each other,
### along with the potential third place runners of the 1st group.
### Returns the final three runners
def take_shortcut(runners):
  first_place = runners[0][0][0]
  deal_breakers = []
  runner_ups_1 = []
  runner_ups_2 = []

  second_1 = None
  second_2 = None
  third_1 = None
  third_2 = None
  third_3 = None

  third_4 = None
  third_5 = None
  third_6 = None


  if len(runners[0][0]) > 1:
    second_1 = runners[0][0][1]
    deal_breakers.append(second_1)
    runner_ups_1.append(second_1)
    runner_ups_2.append(second_1)
    if len(runners[0][0]) > 2:
      third_4 = runners[0][0][2]
      runner_ups_1.append(third_4)

  if len(runners[0]) > 1:
    second_2 = runners[0][1][0]
    deal_breakers.append(second_2)
    runner_ups_1.append(second_2)
    runner_ups_2.append(second_2)
    if len(runners[0][1]) > 1:
      third_5 = runners[0][1][1]
      runner_ups_2.append(third_5)
    if len(runners ) > 2:
      third_6 = runners[0][2][0]
      runner_ups_2.append(third_6)
  if len(runners) > 1:
    potential_second = runners[1][0][0]
    runner_ups_1.append(potential_second)
    runner_ups_2.append(potential_second)
    if len(runners[1][0]) > 1:
      third_1 = runners[1][0][1]
      deal_breakers.append(third_1)
    if len(runners[1]) > 1:
      third_2 = runners[1][1][0]
      deal_breakers.append(third_2)
    if len(runners) > 2:
      third_3 = runners[2][0][0]
      deal_breakers.append(third_3)

  build_print_str(("\n\033[4m" + "Checking for a short cut:" + "\033[0m"))
  db_groups = making_groups(deal_breakers)
  create_grid(db_groups)
  lets_race(deal_breakers)
  db_groups = making_groups(deal_breakers)
  create_grid(db_groups)
  db_winner = get_best(deal_breakers[0])

  # If neither of the first two second place runners are the fastest, then the
  # overall second and third place runners are already found.
  # Otherwise, one more race is still needed.
  if db_winner != get_best(second_1) and db_winner != get_best(second_2):
    build_print_str(("\n\033[1m" + "This time it worked!" + "\033[0m\n"))
    second_place = potential_second
    third_place = deal_breakers[0]
  else:
    runner_ups = []
    if db_winner == get_best(second_1):
      runner_ups = runner_ups_1
    else:
       runner_ups = runner_ups_2
    build_print_str(("\n\033[1m" + "It didn't work!" + "\033[0m\n"))
    build_print_str(("\033[4m" + "Runner-ups:" + "\033[0m"))
    ru_groups = making_groups(runner_ups)
    create_grid(ru_groups)
    lets_race(runner_ups)
    ru_groups = making_groups(runner_ups)
    create_grid(ru_groups)
    second_place = runner_ups[0]
    third_place = runner_ups[1]

  final_three = [first_place, second_place, third_place]
  return final_three

### Returns the runner-ups from a list of sublists of runners.
### Creates a list with runners[0][1], runners[0][2], runners[2][0],
### runners[2][1], and runners[3][0].
### Checks that these are within the bounds of list runners before appending
### runner_ups list.
def get_runnerups(runners):
  runner_ups = []
  if len(runners[0]) > 1:
    runner_ups.append(runners[0][1])
    if len(runners[0]) > 2:
      runner_ups.append(runners[0][2])
  if len(runners) > 1:
    runner_ups.append(runners[1][0])
    if len(runners[1]) > 1:
      runner_ups.append(runners[1][1])
    if len(runners) > 2:
      runner_ups.append(runners[2][0])
  return runner_ups

### Sorts a list and orders them from highest to lowest performance.
### Increments the global int variable num_of_races by 1.
def lets_race(runners):
  global num_of_races

  build_print_str(("\n"+"\033[4m" + "Racers:" + "\033[0m"))
  print_stats(runners)

  if len(runners) > 1:
    num_of_races += 1
    runners.sort(reverse =True, key = get_sort_key)

    build_print_str(("\n" + "\033[4m" + "Results:" + "\033[0m"))
    runner_string = ""
    for i in range(len(runners)):
      runner_string = runner_string + "Runner " + str(get_runner_number(runners[i]))
      if i < (len(runners) - 1):
        runner_string = runner_string + " > "
    build_print_str(("\033[1m" + runner_string + "\033[0m"))
  else:
    build_print_str(("\033[1m" + "No need to race." + "\033[0m\n"))

  print_1stthree(runners)

### Returns a key used by the sort method.
### If it is looking for the key of a list of tuples, it returns the value
### in index 1 of the first tuple, which represents the performance of a runner.
### If it is looking for the key of a list of sublists, it returns the performance
### value of the first tuple in the first index of the list.
def get_sort_key(key):
  if isinstance (key, tuple):
    return key[1]
  if isinstance(key, list):
    return get_sort_key(key[0])

### Saves the number and performance value of a runner stored within a tuple to be printed.
def print_stats(runners):
  for runner in runners:
    contestant = get_best(runner)
    build_print_str(("Runner " + str(contestant[0]) + " : " + str(contestant[1])))

### Returns the tuple of the first runner of a list of runners
def get_best(runners):
  if isinstance(runners, tuple):
    return runners
  else:
    return get_best(runners[0])

### Saves the first three runners in a list to be printed
def print_1stthree(runners):
  build_print_str(("\033[4m" + "First place:" + "\033[0m " + "Runner " + str(get_runner_number(runners[0]))))
  if len(runners) > 1:
    build_print_str(("\033[4m" + "Second place:" + "\033[0m " + "Runner " + str(get_runner_number(runners[1]))))
    if len(runners) > 2:
      build_print_str(("\033[4m" + "Third place:" + "\033[0m " + "Runner "+ str(get_runner_number(runners[2])) + "\n"))

### Setting the number of racers and their performance values.
### Returns a list of tuples.
def defining_runners(num_of_runners):
  # runners is an array of tuples.
  # If you want to access one part of the tuple, set the index to a variable
  # and access its data with either variable[0] or variable[1].
  runners = [(i, np.random.rand()) for i in range(num_of_runners)]
  return runners

### Creates the subgroups to be raced.
### Returns the groups of racers as a list of smaller sublists.
def making_groups(runners):
  racing_groups = []
  i = 0
  while i < len(runners):
    group = []
    for j in range(5):
      if i < len(runners):
        group.append(runners[i])
        i += 1
    racing_groups.append(group)
  return racing_groups

### Returns the value of the global variable num_of_races.
def get_num_of_races():
  global num_of_races
  return num_of_races

### Returns the number of a runner.
def get_runner_number(runner):
  if isinstance (runner, tuple):
    return runner[0]
  if isinstance(runner, list):
    return get_runner_number(runner[0])

### Saves the current runners in a boxed grid for visual representation to be printed.
def create_grid(runners):
  total_length = 4
  if isinstance(runners[0], list):
    for group in runners:
      grid_line = ""
      for runner in group:
        runner_number = get_runner_number(runner)
        contained_num = "[" + str(runner_number).center(total_length, " ") + "]"
        grid_line = grid_line + contained_num
      build_print_str(grid_line)
  else:
    grid_line = ""
    for group in runners:
      runner_number = get_runner_number(group)
      contained_num = "[" + str(runner_number).center(total_length, " ") + "]"
      grid_line = grid_line + contained_num
    build_print_str(grid_line)

### Adds data to the global print_str variable.
def build_print_str(string):
  global print_str
  print_str = print_str + "\n" + str(string)

### Returns the global print_str vairable
def get_print_str():
  global print_str
  return print_str

### Resets the values of the three global variables
def reset_globals():
  global print_str, num_of_races, winner_announcement
  print_str = ""
  num_of_races = 0
  winner_announcement = 0

# PERFORMS ONE ROUND TO FIND THE TOP THREE.
# DISPLAYS TOP 3 RUNNERS AND THE NUMBER OF RACES FOR THE SINGLE ROUND

while True:
    try:
      num_of_runners = int(input("How many racers are there? "))
      if num_of_runners < 2:
        print("You need at least 2 people to race.\n")
        continue
      break

    except ValueError as e:
      print("INVALID INPUT: Please enter a whole number.\n")


runners = defining_runners(num_of_runners)
top_three = initiate_races(runners)

winner_declared = ("\033[4m" + "Overall Winners:" + "\033[0m" + "\n" + "\033[4m"
  + "First place:" + "\033[0m" + " Runner " + str(top_three[0][0]) + " : " + str(top_three[0][1])
  + "\n" + "\033[4m" + "Second place:" + "\033[0m" + " Runner " + str(top_three[1][0])
  + " : " + str(top_three[1][1]) + "\n")
if len(top_three) == 3:
  winner_declared = (winner_declared +"\033[4m" + "Third place:" + "\033[0m"
  + " Runner " + str(top_three[2][0]) + " : " + str(top_three[2][1]))

print(winner_declared)
build_print_str("\n" + winner_declared)

num_of_races = get_num_of_races()
race_count = "\nThe total number of races was " + str(num_of_races)

print(race_count)
build_print_str("\n" + race_count)

# RUNS THE PROGRAM X TIMES FOR N RUNNERS.
# DISPLAYS THE AVERAGE NUMBER OF RACES.

round_counters =[]

while True:
    try:
      num_of_runners = int(input("How many racers are there? \n"))
      if num_of_runners < 2:
        print("You need at least 2 people to race.\n")
        continue
      break

    except ValueError as e:
      print("INVALID INPUT: Please enter a whole number.\n")

while True:
    try:
      num_of_rounds = int(input("How many rounds would you like to run? \n"))
      break

    except ValueError as e:
      print("INVALID INPUT: Please enter a whole number.\n")

for i in range(num_of_rounds):
  reset_globals()
  runners = []
  top_three = []

  runners = defining_runners(num_of_runners)
  top_three = initiate_races(runners)

  round_counters.append(get_num_of_races())

sum = 0
for rounds in round_counters:
  sum = sum + rounds
average = sum/num_of_rounds

print("\nFor " + str(num_of_rounds) + " rounds, there was an average of "
      + "\033[1m" + str(average) + " races per round" + "\033[0m")

# PRINTS OUT DIAGRAMS OF EACH RACING GROUP AND THEIR RESULTS

print(get_print_str())
